# 三月份训练手记

## 3.13 - 1 - [Problem - G - Codeforces](https://codeforces.com/contest/1921/problem/G)

#### 思路

因为这个形状要做前缀和或者区间维护比较困难，所以考虑其他做法

不难发现，在总方格数量在一个可以接受的水平时，从以一个格子为顶点的“区域”变化到与其相邻的一个格子的“区域”只需要去除一段横（或者竖）着的格子，再添加一串斜着的格子即可，在前缀和处理的基础上是可以 $O(1)$ 计算的

于是就考虑暴力计算初始的一部分格点，然后 $O(1)$ 转移

#### 收获&反思

对于一些区间组成很奇怪，一眼看过去不好维护的数据范围，可以考虑用范围数据结构维护，也可以考虑重复利用其中的一部分信息，使用转移来快速计算答案

## 3.13 - 2 - [Problem - E - Codeforces](https://codeforces.com/contest/1920/problem/E)

#### 思路

使用动态规划来解决问题

$01$ 串与总“好子串”之间的关系是显然的，即只与连续的 $0$ 串的长度有关

考虑记 $dp[i][j]$ 表示已经有了 $i$ 个“好子串”且最后一个“好子串”的末尾有 $j$ 个零的方案数量

那么转移方程就是：
$$
\Large dp[i][j]=\sum_{p+j\le k+1}^{j\times p\le i} dp[i-j\times p][p]
$$


#### 收获&反思

这道题很明显是一个动态规划问题，转移起来也不复杂，但是难点在于怎么准确分析复杂度

对于每一个 $i$ 来说，在不考虑上限 $k$ 的影响的时候，最多发生的转移次数就是 $\large\sum_i^n \frac ni \sim n\log n$

事实上，对于 $k$ 的限制总是比 $n$ 更严格，所以一个更强的复杂度渐进上界是 $\large \sum_i^n \frac ni \sim nk\log n$

## 3.13 - 3 - [F - Takahashi in Narrow Road](https://atcoder.jp/contests/abc371/tasks/abc371_f)

#### 思路

本题的难点在于每个点只能占一个人

所以我们考虑把每个人脚下的那个点“藏起来”，使得某种意义上允许格子上站多个人

实现的手段是把每第 $i$ 人的坐标与询问中要他移动到的坐标改为 $x_i-i$ ，这样如果第 $j$ 个人要往前挪动，就必须让他在这基础上多移动 $i-j$ 步，往后移动同理，很巧妙地解决了问题

于是移动就可以化为区间修改操作，统计答案就可以转化为区间求和，用线段树维护即可

#### 收获&反思

很巧妙的处理思路，遇到同样具有“一格一物”性质的问题可以考虑类似的处理手段

## 3.14 - 1 - [Problem - 865D - Codeforces](https://codeforces.com/problemset/problem/865/D)

#### 思路

采用反悔贪心的策略来解决问题

对于每一天，我们选择在此之前**最低价且空闲**的一天来买入并且就在这一天卖出，计算收益

反悔的操作基于：

- 在 $a_j$ 这天决定买入 $a_i$ 之后，我们向可选的项中添加一个 $a_j$ 作为 $a_i$ 的反悔选项，如果后续选择了这一个，仍然等价于以 $a_i$ 买入再以新价格卖出（因为 $a_j$ 被抵消了）

特别地，如果此前最低价也比今日价格高，就不做买入操作

同时还要注意，我们还需要再加入一个 $a_j$ 作为这一天的选项（因为之前买入加入的 $a_j$ 实质上是此前另一天的反悔选项，两者不冲突，所以必须一起考虑）

#### 收获&反思

反悔贪心，目前还是很不熟悉的算法，做一道就赚一道，做两道就赚两道！

## 3.14 - 2 - [Problem - E - Codeforces](https://codeforces.com/contest/1923/problem/E)

#### 思路

本来用各种树上的策略都试了一遍，发现效果都不好，最后看题解去了

使用 **树上启发式合并** 来维护每个节点处所有颜色的“直接子节点”数量，这样子的时间复杂度是合理的

#### 收获&反思

还是没有熟练掌握树上问题，应该意识到 **树上启发式合并** 是一个简单好用的工具

## 3.14 - 3 - [Problem - D1 - Codeforces](https://codeforces.com/contest/1934/problem/D1)

#### 思路

*其实有点狗屎这道题*

不难意识到，最高位和 $x$ 的最高位相同的时候，是可以一步到位的

进而发现，其实只要 $x$ 在目标的最高位上为 $1$ 就可以

所以，对于最高位和 $x$ 的最高位相同的数，我们可以一步构造

而对于最高位低于 $x$ 次高位的数，则可以先将 $x$ 转化为对应的最大全 $1$ 二进制数，然后一步转化

#### 收获&反思

对于构造题，只有多练喵

## 3.15 - 1 - 天梯赛选拔赛 T2-3

#### 思路

不难发现对于一棵树，也就是 $m=n-1$ 的情况来说，只需要将其中节点按照深度奇偶性分为两组，就一定会有一组满足要求的 $\lceil \frac k2 \rceil$ 个独立点

那么就考虑 $m\ge n$ 的情况，这种情况下，不难注意到，题目的要求其实是等价于找到一个环，如果这个环的体量（节点数）是大于 $k$ 的，那么就可以找到一组满足要求的 $\lceil \frac k2 \rceil$ 个独立点，否则，这个环一定满足要求

但是这里有一个纰漏：环上的独立点之间还可能有边相连，这也好办，我们只要让这个环没有任何的“子环”就好了，什么样的环一定没有子环呢：最小的环

于是，我们的任务就变成了寻找最小的环，这是很容易完成的：在DFS遍历的过程中储存节点的父亲与其在DFS树上的深度，之后我们选择深度差最小的返祖边来生成环就好了

#### 收获&反思

非常好树上构造问题，使我的DFS旋转

## 3.18 - 1 - [Problem - E - Codeforces](https://codeforces.com/contest/2075/problem/E)

*数位DP啊，太美妙了*

#### 思路

这道题的思路是之前没有见过的，所以在这里详细记录一下：

首先，由于生成的矩阵只有不超过两种数，所以 $a,b$ 中也必然只有不超过两种数，这个正确性是显而易见的

所以接下来按照 $a,b$ 中不同的数的个数来分类讨论对答案的贡献：

1.  $a,b$ 中均只有一种数
   - 这种情况下， $a,b$ 分别有 $A+1,B+1$ 种选择，所以对答案的贡献是 $(A+1)\times (B+1)$
2. $a,b$ 中有一个包含了两种不同的数，而另一个只有一种数
   - 假如是 $a$ 只有一种数，那么对答案的贡献就是 $(A+1)\times \binom {B+1}2 \times (2^m-2)$
   - 其中 $(2^m-2)$ 意义是这两种数都用上的填满 $b$ 的 $m$ 个空位的不同方案数
   - 同理可得 $b$ 只有一种数时的贡献 $(B+1)\times \binom {A+1}2 \times (2^n-2)$
3. 最后一种，也是最麻烦的一种：$a,b$ 均包含了两种不同的数
   - 假设包含的数分别为 $p_a,q_a$ 与 $p_b,q_b$ ，那么根据题设限制 ，必有 $p_a\oplus p_b= q_a \oplus q_b$ 与 $p_a\oplus q_b= q_a \oplus p_b$ ，其实这两个条件是等价的，即 $p_a\oplus p_b \oplus q_a \oplus q_b=0$ 
   - 于是我们就要统计符合要求的数对数目
   - 考虑数位dp，用 $dp[i][j]$ 来表示从高到低填到第 $i$ 位，并且当前对数位限制情况为 $j$ 的方案数量，其中 $j$ 是一个 $[0,15]$ 取值的四位状态压缩量
   - 转移的时候考虑对当前位填 $0,1$ 的情况，再检查是否违反了数位限制，对于合法的填入方法，我们要对于那些原来有数位限制，但填入的数小于原有数位的地方解除数位限制
   - 最后统计答案的时候，因为每一个有序二元组会被统计两次，所以合法方案会被统计 $4$ 次，并且其中还会有 $(A+1)\times (B+1)$ 个方案来自 $p_a=q_a,p_b=q_b$ 需要先减去

##### 收获&反思

数位dp是很好的东西啊，感觉需要找时间多找几道题做做

## 3.19 - 1 - [Problem - B - Codeforces](https://codeforces.com/contest/1924/problem/B)

#### 思路

其实很容易发现就是用线段树维护区间和，并且实现区间修改

要点在于：

1. 如何找到要求改的区间
   - 可以使用一个 `set` 维护现有的每个区间，然后使用 `set.lower_bound()` 查找区间
   - 修改就直接删除原来的区间，插入新的区间
2. 如何用线段树维护等差数列
   - 可以让修改tag保存 $0$ 下标处的首项与公差，实现确定一个区间内的等差数列

####  收获&反思

其实就是线段树基本技巧，写一遍找找手感挺好

## 3.20 - 1 - [Problem - F - Codeforces](https://codeforces.com/contest/1933/problem/F)

#### 思路

因为题目有着令人晕头转向的背景，所以考虑转化问题为较自然，较简单的模型

每秒钟的时候，整个地图会向上“滚动”，所有的地形（终点除外）将会一起移动，我们显然没有办法维护地形的改变，但是不难发现，在大家都可以滚动的条件下，这与我们自身向下移动一格是等价的

于是考虑把问题转化为如下模型：

- 地形不动，每次可以选择
  1. 相对不动，开销为 $1$
  2. 向右一格，同时向下一格，开销为 $1$
  3. 向下两格，开销为 $1$
- 在此基础上发现，操作 1 完全没用，所以接下来的求解过程中不予考虑

这个问题的求解可以靠 BFS 轻松完成，但是最后怎么计算到达终点的最小开销呢？

首先明确以下结论：

- 要到达终点必须先到达倒数第二列的某个格子
- 考虑固定到达倒数第二列的某个格子，那么一定是越早到达越好，不会有“后效性”，因为最后一列没有障碍物

所以我们只要枚举最小开销的方案经过的倒数第二列的格子，然后根据此时的“开销”计算出终点的位置，进而计算出这种情况下的最小开销就可以了

#### 收获&反思

原先是考虑用 DP 来写的，但是发现有后效性，在这种开销均为 1 的模型中可以考虑 BFS（开销不为 1 的，有后效性的格点模型也可以考虑最短路算法）

最后对于答案的生成的结论是解出本题的关键，它是一个不那么显然的贪心，再次验证了：“贪心不证明等于耍流氓”

## 3.20 - 2 - [Problem - G - Codeforces](https://codeforces.com/contest/1931/problem/G)

#### 思路

不难发现，凹糟的数量要满足一定要求才能成功组合出要求的链

具体地，这个数量要求是 1 类拼图与 2 类拼图的数量之差不超过 $1$ ，原因如下：

- 递推可知，3、4类拼图不会改变两端的凹槽形状，而1、2类一定会
- 所以可以想象把3、4类拼图全部去掉，剩下的一定是1、2类拼图的交替结构，结论就显然了

受到上述证明方案存在性的途径的启发，也不难想到统计方案数的方法：

- 1、2类拼图的摆放方式固定（数量相同的情况下有两种摆放方法），此时方案数就是把3、4类拼图嵌入其中的方案数
- 这是经典的组合数学问题：把 $m$ 个等价的物品放入 $n$ 个盒子中，盒子可以为空，不同的方案数有 $\large\binom {n+m-1}{m-1}$ 种

于是就很轻松地做完了

#### 收获&反思

组合问题的几种常见解决方法：

- 使用 DP 来解决问题
- （本题）直接观察出结论，化为常见的组合数学模型
- 转化为关联性问题，使用并查集/图/DFS等来解决

## 3.21 - 1 - [P3295 [SCOI2016] 萌萌哒 - 洛谷](https://www.luogu.com.cn/problem/P3295)

*倍增还能这么玩？？？*

#### 思路

其实直接读题不难发现题目想要我们干什么：两个子串相同，等价于两个子串上的字符一一对应相同

而等价关系具有传递性，也就是“结合律”，所以可以考虑使用并查集来维护

但是！直接使用并查集，会让 `merge` 操作的开销来到无法接受的 $O(n^2)$ 所以要考虑如何优化

这个思路很 `nm` 巧妙哇！

因为我们复杂度的罪魁祸首是区间长度，区间长度越长，我们要进行的 `merge` 操作的量也就越多，想一想什么东西可以管上长区间处理呢？

对的！就是二进制分解。

具体地，在这道题中体现为我们使用类似于“倍增” 的思想，对于长度为 $2^k$ 的子串分别开一组并查集，然后将长子串二进制分解，在不同的并查集上分别进行 `merge` 操作

最后统计答案的时候，从高到低逐层将 `merge` 信息 down 下来，显然每层最多只会有 $n$ 次 `merge` ，所以时间复杂度为可以接受的 $O(n\log n)$

#### 收获&反思

对于长区间的处理应该自然联想到二进制分解，多看一些二进制分解与各种数据结构结合的实例

优雅，永不过时喵！

## 3.21 - 2 - [Problem - F - Codeforces](https://codeforces.com/contest/1926/problem/F)

#### 思路

看到题目发现最大的一个特点是地图大小固定为 $7\times 7$ 所以考虑找一些性质

又不难发现，格子之间的影响只通过斜向“传播”，所以完全可以把所有的格子分成互不影响的两组

观察其中任意一组，发现至多可以用 $4$ 次操作来合法化，所以我们只要找小于四次的操作就好了

直接暴力枚举，然后check，开销量小于 $(24^3+25^3)\times 7^2<2e6$ 

#### 收获&反思

之前被一道可以暴力完成的题目坑过，之后就知道了，暴力+证明=合法地耍流氓

## 3.22 - 1 - [Problem - B - Codeforces](https://codeforces.com/contest/1943/problem/B)

#### 思路

首先，你要知道 $manacher$ 算法

然后，你要注意到 $k=1$ 一定成立

再然后，你要注意到 $k$ 为奇数的时候，要求奇数位与偶数位上分别相同，$k$ 为偶数的时候，要求全部相同

最后，随便拿个什么东西维护这个性质

#### 收获&反思

学习了 $manacher$ 相当的厉害啊（赞赏）

## 3.24 - 1 - [Problem - D - Codeforces](https://codeforces.com/contest/1942/problem/D)

