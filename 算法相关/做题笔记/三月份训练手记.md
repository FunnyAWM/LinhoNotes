# 三月份训练手记

## 3.13 - 1 - [Problem - G - Codeforces](https://codeforces.com/contest/1921/problem/G)

#### 思路

因为这个形状要做前缀和或者区间维护比较困难，所以考虑其他做法

不难发现，在总方格数量在一个可以接受的水平时，从以一个格子为顶点的“区域”变化到与其相邻的一个格子的“区域”只需要去除一段横（或者竖）着的格子，再添加一串斜着的格子即可，在前缀和处理的基础上是可以 $O(1)$ 计算的

于是就考虑暴力计算初始的一部分格点，然后 $O(1)$ 转移

#### 收获&反思

对于一些区间组成很奇怪，一眼看过去不好维护的数据范围，可以考虑用范围数据结构维护，也可以考虑重复利用其中的一部分信息，使用转移来快速计算答案

## 3.13 - 2 - [Problem - E - Codeforces](https://codeforces.com/contest/1920/problem/E)

#### 思路

使用动态规划来解决问题

$01$ 串与总“好子串”之间的关系是显然的，即只与连续的 $0$ 串的长度有关

考虑记 $dp[i][j]$ 表示已经有了 $i$ 个“好子串”且最后一个“好子串”的末尾有 $j$ 个零的方案数量

那么转移方程就是：
$$
\Large dp[i][j]=\sum_{p+j\le k+1}^{j\times p\le i} dp[i-j\times p][p]
$$


#### 收获&反思

这道题很明显是一个动态规划问题，转移起来也不复杂，但是难点在于怎么准确分析复杂度

对于每一个 $i$ 来说，在不考虑上限 $k$ 的影响的时候，最多发生的转移次数就是 $\large\sum_i^n \frac ni \sim n\log n$

事实上，对于 $k$ 的限制总是比 $n$ 更严格，所以一个更强的复杂度渐进上界是 $\large \sum_i^n \frac ni \sim nk\log n$

## 3.13 - 3 - [F - Takahashi in Narrow Road](https://atcoder.jp/contests/abc371/tasks/abc371_f)

#### 思路

本题的难点在于每个点只能占一个人

所以我们考虑把每个人脚下的那个点“藏起来”，使得某种意义上允许格子上站多个人

实现的手段是把每第 $i$ 人的坐标与询问中要他移动到的坐标改为 $x_i-i$ ，这样如果第 $j$ 个人要往前挪动，就必须让他在这基础上多移动 $i-j$ 步，往后移动同理，很巧妙地解决了问题

于是移动就可以化为区间修改操作，统计答案就可以转化为区间求和，用线段树维护即可

#### 收获&反思

很巧妙的处理思路，遇到同样具有“一格一物”性质的问题可以考虑类似的处理手段

## 3.14 - 1 - [Problem - 865D - Codeforces](https://codeforces.com/problemset/problem/865/D)

#### 思路

采用反悔贪心的策略来解决问题

对于每一天，我们选择在此之前**最低价且空闲**的一天来买入并且就在这一天卖出，计算收益

反悔的操作基于：

- 在 $a_j$ 这天决定买入 $a_i$ 之后，我们向可选的项中添加一个 $a_j$ 作为 $a_i$ 的反悔选项，如果后续选择了这一个，仍然等价于以 $a_i$ 买入再以新价格卖出（因为 $a_j$ 被抵消了）

特别地，如果此前最低价也比今日价格高，就不做买入操作

同时还要注意，我们还需要再加入一个 $a_j$ 作为这一天的选项（因为之前买入加入的 $a_j$ 实质上是此前另一天的反悔选项，两者不冲突，所以必须一起考虑）

#### 收获&反思

反悔贪心，目前还是很不熟悉的算法，做一道就赚一道，做两道就赚两道！

## 3.14 - 2 - [Problem - E - Codeforces](https://codeforces.com/contest/1923/problem/E)

#### 思路

本来用各种树上的策略都试了一遍，发现效果都不好，最后看题解去了

使用 **树上启发式合并** 来维护每个节点处所有颜色的“直接子节点”数量，这样子的时间复杂度是合理的

#### 收获&反思

还是没有熟练掌握树上问题，应该意识到 **树上启发式合并** 是一个简单好用的工具

## 3.14 - 3 - [Problem - D1 - Codeforces](https://codeforces.com/contest/1934/problem/D1)

#### 思路

*其实有点狗屎这道题*

不难意识到，最高位和 $x$ 的最高位相同的时候，是可以一步到位的

进而发现，其实只要 $x$ 在目标的最高位上为 $1$ 就可以

所以，对于最高位和 $x$ 的最高位相同的数，我们可以一步构造

而对于最高位低于 $x$ 次高位的数，则可以先将 $x$ 转化为对应的最大全 $1$ 二进制数，然后一步转化

#### 收获&反思

对于构造题，只有多练喵

