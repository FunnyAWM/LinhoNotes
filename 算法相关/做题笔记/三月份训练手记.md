# 三月份训练手记

## 3.13 - 1 - [Problem - G - Codeforces](https://codeforces.com/contest/1921/problem/G)

#### 思路

因为这个形状要做前缀和或者区间维护比较困难，所以考虑其他做法

不难发现，在总方格数量在一个可以接受的水平时，从以一个格子为顶点的“区域”变化到与其相邻的一个格子的“区域”只需要去除一段横（或者竖）着的格子，再添加一串斜着的格子即可，在前缀和处理的基础上是可以 $O(1)$ 计算的

于是就考虑暴力计算初始的一部分格点，然后 $O(1)$ 转移

#### 收获&反思

对于一些区间组成很奇怪，一眼看过去不好维护的数据范围，可以考虑用范围数据结构维护，也可以考虑重复利用其中的一部分信息，使用转移来快速计算答案

## 3.13 - 2 - [Problem - E - Codeforces](https://codeforces.com/contest/1920/problem/E)

#### 思路

使用动态规划来解决问题

$01$ 串与总“好子串”之间的关系是显然的，即只与连续的 $0$ 串的长度有关

考虑记 $dp[i][j]$ 表示已经有了 $i$ 个“好子串”且最后一个“好子串”的末尾有 $j$ 个零的方案数量

那么转移方程就是：
$$
\Large dp[i][j]=\sum_{p+j\le k+1}^{j\times p\le i} dp[i-j\times p][p]
$$


#### 收获&反思

这道题很明显是一个动态规划问题，转移起来也不复杂，但是难点在于怎么准确分析复杂度

对于每一个 $i$ 来说，在不考虑上限 $k$ 的影响的时候，最多发生的转移次数就是 $\large\sum_i^n \frac ni \sim n\log n$

事实上，对于 $k$ 的限制总是比 $n$ 更严格，所以一个更强的复杂度渐进上界是 $\large \sum_i^n \frac ni \sim nk\log n$

## 3.13 - 3 - [F - Takahashi in Narrow Road](https://atcoder.jp/contests/abc371/tasks/abc371_f)

#### 思路

本题的难点在于每个点只能占一个人

所以我们考虑把每个人脚下的那个点“藏起来”，使得某种意义上允许格子上站多个人

实现的手段是把每第 $i$ 人的坐标与询问中要他移动到的坐标改为 $x_i-i$ ，这样如果第 $j$ 个人要往前挪动，就必须让他在这基础上多移动 $i-j$ 步，往后移动同理，很巧妙地解决了问题

于是移动就可以化为区间修改操作，统计答案就可以转化为区间求和，用线段树维护即可

#### 收获&反思

很巧妙的处理思路，遇到同样具有“一格一物”性质的问题可以考虑类似的处理手段

## 3.14 - 1 - [Problem - 865D - Codeforces](https://codeforces.com/problemset/problem/865/D)

#### 思路

采用反悔贪心的策略来解决问题

对于每一天，我们选择在此之前**最低价且空闲**的一天来买入并且就在这一天卖出，计算收益

反悔的操作基于：

- 在 $a_j$ 这天决定买入 $a_i$ 之后，我们向可选的项中添加一个 $a_j$ 作为 $a_i$ 的反悔选项，如果后续选择了这一个，仍然等价于以 $a_i$ 买入再以新价格卖出（因为 $a_j$ 被抵消了）

特别地，如果此前最低价也比今日价格高，就不做买入操作

同时还要注意，我们还需要再加入一个 $a_j$ 作为这一天的选项（因为之前买入加入的 $a_j$ 实质上是此前另一天的反悔选项，两者不冲突，所以必须一起考虑）

#### 收获&反思

反悔贪心，目前还是很不熟悉的算法，做一道就赚一道，做两道就赚两道！

## 3.14 - 2 - [Problem - E - Codeforces](https://codeforces.com/contest/1923/problem/E)

#### 思路

本来用各种树上的策略都试了一遍，发现效果都不好，最后看题解去了

使用 **树上启发式合并** 来维护每个节点处所有颜色的“直接子节点”数量，这样子的时间复杂度是合理的

#### 收获&反思

还是没有熟练掌握树上问题，应该意识到 **树上启发式合并** 是一个简单好用的工具

## 3.14 - 3 - [Problem - D1 - Codeforces](https://codeforces.com/contest/1934/problem/D1)

#### 思路

*其实有点狗屎这道题*

不难意识到，最高位和 $x$ 的最高位相同的时候，是可以一步到位的

进而发现，其实只要 $x$ 在目标的最高位上为 $1$ 就可以

所以，对于最高位和 $x$ 的最高位相同的数，我们可以一步构造

而对于最高位低于 $x$ 次高位的数，则可以先将 $x$ 转化为对应的最大全 $1$ 二进制数，然后一步转化

#### 收获&反思

对于构造题，只有多练喵

## 3.15 - 1 - 天梯赛选拔赛 T2-3

#### 思路

不难发现对于一棵树，也就是 $m=n-1$ 的情况来说，只需要将其中节点按照深度奇偶性分为两组，就一定会有一组满足要求的 $\lceil \frac k2 \rceil$ 个独立点

那么就考虑 $m\ge n$ 的情况，这种情况下，不难注意到，题目的要求其实是等价于找到一个环，如果这个环的体量（节点数）是大于 $k$ 的，那么就可以找到一组满足要求的 $\lceil \frac k2 \rceil$ 个独立点，否则，这个环一定满足要求

但是这里有一个纰漏：环上的独立点之间还可能有边相连，这也好办，我们只要让这个环没有任何的“子环”就好了，什么样的环一定没有子环呢：最小的环

于是，我们的任务就变成了寻找最小的环，这是很容易完成的：在DFS遍历的过程中储存节点的父亲与其在DFS树上的深度，之后我们选择深度差最小的返祖边来生成环就好了

#### 收获&反思

非常好树上构造问题，使我的DFS旋转

## 3.18 - 1 - [Problem - E - Codeforces](https://codeforces.com/contest/2075/problem/E)

*数位DP啊，太美妙了*

#### 思路

这道题的思路是之前没有见过的，所以在这里详细记录一下：

首先，由于生成的矩阵只有不超过两种数，所以 $a,b$ 中也必然只有不超过两种数，这个正确性是显而易见的

所以接下来按照 $a,b$ 中不同的数的个数来分类讨论对答案的贡献：

1.  $a,b$ 中均只有一种数
   - 这种情况下， $a,b$ 分别有 $A+1,B+1$ 种选择，所以对答案的贡献是 $(A+1)\times (B+1)$
2. $a,b$ 中有一个包含了两种不同的数，而另一个只有一种数
   - 假如是 $a$ 只有一种数，那么对答案的贡献就是 $(A+1)\times \binom {B+1}2 \times (2^m-2)$
   - 其中 $(2^m-2)$ 意义是这两种数都用上的填满 $b$ 的 $m$ 个空位的不同方案数
   - 同理可得 $b$ 只有一种数时的贡献 $(B+1)\times \binom {A+1}2 \times (2^n-2)$
3. 最后一种，也是最麻烦的一种：$a,b$ 均包含了两种不同的数
   - 假设包含的数分别为 $p_a,q_a$ 与 $p_b,q_b$ ，那么根据题设限制 ，必有 $p_a\oplus p_b= q_a \oplus q_b$ 与 $p_a\oplus q_b= q_a \oplus p_b$ ，其实这两个条件是等价的，即 $p_a\oplus p_b \oplus q_a \oplus q_b=0$ 
   - 于是我们就要统计符合要求的数对数目
   - 考虑数位dp，用 $dp[i][j]$ 来表示从高到低填到第 $i$ 位，并且当前对数位限制情况为 $j$ 的方案数量，其中 $j$ 是一个 $[0,15]$ 取值的四位状态压缩量
   - 转移的时候考虑对当前位填 $0,1$ 的情况，再检查是否违反了数位限制，对于合法的填入方法，我们要对于那些原来有数位限制，但填入的数小于原有数位的地方解除数位限制
   - 最后统计答案的时候，因为每一个有序二元组会被统计两次，所以合法方案会被统计 $4$ 次，并且其中还会有 $(A+1)\times (B+1)$ 个方案来自 $p_a=q_a,p_b=q_b$ 需要先减去

##### 收获&反思

数位dp是很好的东西啊，感觉需要找时间多找几道题做做

## 3.19 - 1 - [Problem - B - Codeforces](https://codeforces.com/contest/1924/problem/B)

#### 思路

其实很容易发现就是用线段树维护区间和，并且实现区间修改

要点在于：

1. 如何找到要求改的区间
   - 可以使用一个 `set` 维护现有的每个区间，然后使用 `set.lower_bound()` 查找区间
   - 修改就直接删除原来的区间，插入新的区间
2. 如何用线段树维护等差数列
   - 可以让修改tag保存 $0$ 下标处的首项与公差，实现确定一个区间内的等差数列

####  收获&反思

其实就是线段树基本技巧，写一遍找找手感挺好



