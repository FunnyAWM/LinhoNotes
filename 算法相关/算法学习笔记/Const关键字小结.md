# `Const`关键字小结

const 是 constant 的缩写，本意是不变的，不易改变的意思。在 C++ 中是用来修饰内置类型变量，自定义对象，成员函数，返回值，函数参数。

C++ const 允许指定一个语义约束，编译器会**强制实施**这个约束，允许程序员告诉编译器某值是保持不变的。如果在编程中确实有某个值保持不变，就应该明确使用const，这样可以获得编译器的帮助。

## `const` 修饰普通类型的变量

```cpp
const int  a = 7; 
int  b = a; // 正确
a = 8;       // 错误，不能改变
```

a 被定义为一个常量，并且可以将 a 赋值给 b，但是不能给 a 再次赋值。对一个常量赋值是违法的事情，因为 a 被编译器认为是一个常量，其值不允许修改。

## `const` 修饰指针变量（或引用）

const 修饰指针变量有以下三种情况。

- A: const 修饰指针指向的内容，则内容为不可变量。
- B: const 修饰指针，则指针为不可变量。
- C: const 修饰指针和指针指向的内容，则指针和指针指向的内容都为不可变量。

对于 A:

```cpp
const int *p = 8;
```

则指针指向的内容 8 不可改变。简称左定值，因为 const 位于 * （或 & ）号的左边。

对于 B:

```cpp
int a = 8;
int* const p = &a;
*p = 9; // 正确
int  b = 7;
p = &b; // 错误
```

对于指针 p ，其指向的内存地址不能够被改变，但其内容可以改变。简称，右定向。因为 const 位于 * 号的右边（引用不是一个变量，故这一条中“其内容可以改变”不适用，但其与另外两种 const 引用仍有区别）。

对于 C: **则是 A 和 B的合并**

```cpp
int a = 8;
const int * const  p = &a;
```

这时，p 的指向的内容和指向的内存地址都已固定，不可改变。

对于引用，同理。

对于 A，B，C 三种情况，根据 const 位于 * （或 & ）号的位置不同，我总结三句话便于记忆的话：**"左定值，右定向，const修饰不变量"**。

## `const`修饰函数

**在类中**将成员函数修饰为const表明在该函数体内， **不能修改对象的数据成员**而且**不能调用非const函数**。为什么不能调用非const函数？因为非const函数可能修改数据成员，const成员函数是不能修改数据成员的，所以在const成员函数内只能调用const函数。

```cpp
class A{
private:
	int i;
public:
	void set(int n){ //set函数需要设置i的值，所以不能声明为const
		i = n;
	}
 
	int get() const{ //get函数返回i的值，不需要对i进行修改，则可以用const修饰。防止在函数体内对i进行修改。
		return i;
	}
};
```

值得注意的是，把一个成员函数声明为const可以保证这个成员函数不修改数据成员，但是，如果据成员是指针，则const成员函数并**不能保证**不修改指针指向的对象，编译器不会把这种修改检测为错误。

## `const`修饰函数参数

在函数体内是不能改变i的值的，但是没有任何实际意义。
const修饰的函数参数是指针时,代表 **在函数体内不能修改该指针所指的内容，起到保护作用**，在字符串复制的函数中保证不修改源字符串的情况下，实现字符串的复制。

```cpp
void fun(const char * src, char * des){  //保护源字符串不被修改，若修改src则编译可能出错。
	strcpy(des,src);
}
void main(){
	char a[10]="china";
	char b[20];
	fun(a,b);
	cout<<b<<endl;
}
```

而且 **const指针可以接收非const和const指针，而非const指针只能接收非const指针。**

const修饰引用时：如果函数参数为用户自定义的类对象如：

```cpp
void h(A a){
//......
}
```

传递进来的参数a是实参对象的副本，要调用**构造函数**来构造这个副本，而且函数结束后要调用**析构函数**来释放这个副本，在空间和时间上都造成了浪费，所以函数参数为类对象的情况，推荐用**引用**。但按引用传递，造成了安全隐患，通过函数参数的引用可以修改实参的内部数据成员，所以用const来**保护实参**。

```cpp
void h(const A & a){
//......
}
```

## `const`修饰函数返回值

也是用const来修饰返回的指针或引用，保护指针指向的内容或引用的内容不被修改，也常用于运算符重载。归根究底就是 **使得函数调用表达式不能作为左值**。

```cpp
#include <iostream>  
using namespace std;  
  
class A {
private:
	int i;
public:
	A(){i=0;}
	int & get(){
		return i;
	}
};
 
void main(){
	A a;
	cout<<a.get()<<endl; //数据成员值为0
	a.get()=1; //尝试修改a对象的数据成员为1，而且是用函数调用表达式作为左值。
	cout<<a.get()<<endl; //数据成员真的被改为1了，返回指针的情况也可以修改成员i的值，所以为了安全起见最好在返回值加上const，使得函数调用表达式不能作为左值
}
```

