# [Codeforces Round 988](https://codeforces.com/contest/2037) 赛后复盘

*写代码的效率还是太慢了*

## [E. Kachina's Favorite Binary String](https://codeforces.com/contest/2037/problem/E)

思路比较简单的交互题，但是细节处理较多（也有可能是个人的处理方法不够优）

需要多练习特殊处理的能力，在写代码的时候避免畏难情绪（尤其不要跑去玩手机了）

## [F. Ardent Flames](https://codeforces.com/contest/2037/problem/F)

*施工中......*

## [G. Natlan Exploring](https://codeforces.com/contest/2037/problem/G)

一眼动态规划，也想出来了通过质因数分解来简化转化过程，但是囿于做题经验少，对于时间复杂度的感知能力不够强，导致在想思路的时候一直卡在“如何去重”上面，后面看了题解发现直接暴力使用容斥原理，复杂度常数只有 $2^7=128$ 完全可以接受，唉唉，还好时间本来就来不及，不然又要后悔（ 

### AC代码

```cpp
#include<iostream>
#include<map>
#include<set>
#include<ctime>
#include<cmath>
#include<queue>
#include<vector>
#include<random>
#include<string>
#include<algorithm>

using namespace std;

mt19937_64 rnd( time( 0 ) );

typedef long long ll;
typedef uint64_t ull;


const ll INF = 1e18,
Mod = 998244353;

const ll MAXN=1e6+1;

ll n;
ll mob[1000010],pr[1000010],a[200010],dp[1000010];

void init(){
	for(ll i=1;i<=MAXN;i++)
		pr[i]=i,mob[i]=1;
	for(ll i=2;i<=MAXN;i++){
		if(pr[i]==i){
			for(ll j=i;j<=MAXN;j+=i)
				pr[j]=min(pr[j],i);
			mob[i]=-1;
		}
			
	}
	mob[1]=1;
	for(ll i=2;i<=MAXN;i++){
		if(pr[i]==pr[i/pr[i]])
			mob[i]=0;
		else
			mob[i]=mob[i/pr[i]]*mob[pr[i]];
	}
	mob[1]=0;
//	for(ll i=1;i<=100;i++)
//		cout<<i<<' '<<mob[i]<<endl;	
}

ll DFS(vector<ll> &v,ll st,ll w){
	
	if(w==v.size()){
		if(st==1) return 0;
//		cout<<"!!"<<st<<' '<<dp[st]<<endl;
		return dp[st]*(-mob[st]);
	}
		
	return (DFS(v,st,w+1)+DFS(v,st*v[w],w+1))%Mod;
}

void change(vector<ll> &v,ll st,ll w,ll ans){
	if(w==v.size()){
		if(st==1) return;
//		cout<<st<<' '<<ans<<endl;
		dp[st]=(dp[st]+ans)%Mod;
		return;
	}
	
	change(v,st,w+1,ans);
	change(v,st*v[w],w+1,ans);
}

int main() {
	ios::sync_with_stdio( 0 );
	cin.tie( 0 );
	cout.tie( 0 );
	
	cin>>n;
	init();
	
	for(ll i=1;i<=n;i++)
		cin>>a[i];
	
	for(ll i=1;i<=n;i++){
		ll x=a[i],ans=0;
		vector<ll> v;
		while(x>1){
			if(v.empty()||*v.rbegin()!=pr[x])
				v.emplace_back(pr[x]);
			x/=pr[x];
		}
		if(i==1){
			change(v,1,0,1);
			continue;
		}
		ans=DFS(v,1,0);
		change(v,1,0,ans);
		
//		cout<<">>>>>>"<<ans<<endl;
		if(i==n)
			cout<<(ans+Mod)%Mod<<endl;
	}
	return 0;

```

### 注意事项

- 经典的素数处理方法——先离线处理其最小质因数，后在线按需求取对应数据（所有质因数，因子数等等）
- DFS处理遍历问题，传入参数不要省略，对于 vector 传入引用，注意终止条件的判断和无效状况的筛选
- 不可在 vector 容器为空的时候访问其首尾指针，需要加一个特判
